<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Connected Home over IP: chip::Encoding::LittleEndian Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Connected Home over IP
   &#160;<span id="projectnumber">672cf7684</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacechip_1_1_encoding_1_1_little_endian.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">chip::Encoding::LittleEndian Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_encoding_1_1_little_endian_1_1_buffer_writer.html">BufferWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_encoding_1_1_little_endian_1_1_reader.html">Reader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0459604c3ee9bf6cfc40add037ab08e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a0459604c3ee9bf6cfc40add037ab08e3">PacketBufferWriter</a> = <a class="el" href="classchip_1_1_encoding_1_1_packet_buffer_writer_base.html">PacketBufferWriterBase</a>&lt; <a class="el" href="classchip_1_1_encoding_1_1_little_endian_1_1_buffer_writer.html">chip::Encoding::LittleEndian::BufferWriter</a> &gt;</td></tr>
<tr class="separator:a0459604c3ee9bf6cfc40add037ab08e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2d72145b506ff674ee188d2ce048126f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a2d72145b506ff674ee188d2ce048126f">HostSwap16</a> (uint16_t v)</td></tr>
<tr class="memdesc:a2d72145b506ff674ee188d2ce048126f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This conditionally performs, as necessary for the target system, a byte order swap by value of the specified 16-bit value, presumed to be in little endian byte ordering to the target system (i.e.  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#a2d72145b506ff674ee188d2ce048126f">More...</a><br /></td></tr>
<tr class="separator:a2d72145b506ff674ee188d2ce048126f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c5268e4ad53dcb8945af270f0b17b1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a03c5268e4ad53dcb8945af270f0b17b1">HostSwap32</a> (uint32_t v)</td></tr>
<tr class="memdesc:a03c5268e4ad53dcb8945af270f0b17b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This conditionally performs, as necessary for the target system, a byte order swap by value of the specified 32-bit value, presumed to be in little endian byte ordering to the target system (i.e.  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#a03c5268e4ad53dcb8945af270f0b17b1">More...</a><br /></td></tr>
<tr class="separator:a03c5268e4ad53dcb8945af270f0b17b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc7ea2318459a8c6385fafea9c63fb3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#aefc7ea2318459a8c6385fafea9c63fb3">HostSwap64</a> (uint64_t v)</td></tr>
<tr class="memdesc:aefc7ea2318459a8c6385fafea9c63fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This conditionally performs, as necessary for the target system, a byte order swap by value of the specified 64-bit value, presumed to be in little endian byte ordering to the target system (i.e.  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#aefc7ea2318459a8c6385fafea9c63fb3">More...</a><br /></td></tr>
<tr class="separator:aefc7ea2318459a8c6385fafea9c63fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada986f033af897efecd4ccdc1d59bde6"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#ada986f033af897efecd4ccdc1d59bde6">Get16</a> (const uint8_t *p)</td></tr>
<tr class="memdesc:ada986f033af897efecd4ccdc1d59bde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory read of the little endian byte ordered 16-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering.  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#ada986f033af897efecd4ccdc1d59bde6">More...</a><br /></td></tr>
<tr class="separator:ada986f033af897efecd4ccdc1d59bde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5c91cdceeef2f64f41155b162087fb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#abc5c91cdceeef2f64f41155b162087fb">Get32</a> (const uint8_t *p)</td></tr>
<tr class="memdesc:abc5c91cdceeef2f64f41155b162087fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory read of the little endian byte ordered 32-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering.  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#abc5c91cdceeef2f64f41155b162087fb">More...</a><br /></td></tr>
<tr class="separator:abc5c91cdceeef2f64f41155b162087fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403fc75ec23bcada414823fb4627bc9a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a403fc75ec23bcada414823fb4627bc9a">Get64</a> (const uint8_t *p)</td></tr>
<tr class="memdesc:a403fc75ec23bcada414823fb4627bc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory read of the little endian byte ordered 64-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering.  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#a403fc75ec23bcada414823fb4627bc9a">More...</a><br /></td></tr>
<tr class="separator:a403fc75ec23bcada414823fb4627bc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dfe448d79c9e0f966af13b2fb90baf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a48dfe448d79c9e0f966af13b2fb90baf">Put16</a> (uint8_t *p, uint16_t v)</td></tr>
<tr class="memdesc:a48dfe448d79c9e0f966af13b2fb90baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory write of the target system byte ordered 16-bit value to the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in little endian byte ordering.  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#a48dfe448d79c9e0f966af13b2fb90baf">More...</a><br /></td></tr>
<tr class="separator:a48dfe448d79c9e0f966af13b2fb90baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31231f899bbec463f5fcee19734581fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a31231f899bbec463f5fcee19734581fb">Put32</a> (uint8_t *p, uint32_t v)</td></tr>
<tr class="memdesc:a31231f899bbec463f5fcee19734581fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory write of the target system byte ordered 32-bit value to the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in little endian byte ordering.  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#a31231f899bbec463f5fcee19734581fb">More...</a><br /></td></tr>
<tr class="separator:a31231f899bbec463f5fcee19734581fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630396930c94e3f410f89f3de5f62161"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a630396930c94e3f410f89f3de5f62161">Put64</a> (uint8_t *p, uint64_t v)</td></tr>
<tr class="memdesc:a630396930c94e3f410f89f3de5f62161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory write of the target system byte ordered 64-bit value to the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in little endian byte ordering.  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#a630396930c94e3f410f89f3de5f62161">More...</a><br /></td></tr>
<tr class="separator:a630396930c94e3f410f89f3de5f62161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e38e5cb39ab0fa8b8158001c8e20ffd"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a3e38e5cb39ab0fa8b8158001c8e20ffd">Read16</a> (const uint8_t *&amp;p)</td></tr>
<tr class="memdesc:a3e38e5cb39ab0fa8b8158001c8e20ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory read of the little endian byte ordered 16-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering, and increment the pointer by 16-bits (2 bytes).  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#a3e38e5cb39ab0fa8b8158001c8e20ffd">More...</a><br /></td></tr>
<tr class="separator:a3e38e5cb39ab0fa8b8158001c8e20ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20965fe08826d3ab9b20229a146c72c3"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a20965fe08826d3ab9b20229a146c72c3">Read16</a> (uint8_t *&amp;p)</td></tr>
<tr class="memdesc:a20965fe08826d3ab9b20229a146c72c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory read of the little endian byte ordered 16-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering, and increment the pointer by 16-bits (2 bytes).  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#a20965fe08826d3ab9b20229a146c72c3">More...</a><br /></td></tr>
<tr class="separator:a20965fe08826d3ab9b20229a146c72c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0a2d905650b2672238de0219847290"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a1a0a2d905650b2672238de0219847290">Read32</a> (const uint8_t *&amp;p)</td></tr>
<tr class="memdesc:a1a0a2d905650b2672238de0219847290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory read of the little endian byte ordered 32-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering, and increment the pointer by 32-bits (4 bytes).  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#a1a0a2d905650b2672238de0219847290">More...</a><br /></td></tr>
<tr class="separator:a1a0a2d905650b2672238de0219847290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745a39814ee191f008cfe05513726483"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a745a39814ee191f008cfe05513726483">Read32</a> (uint8_t *&amp;p)</td></tr>
<tr class="memdesc:a745a39814ee191f008cfe05513726483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory read of the little endian byte ordered 32-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering, and increment the pointer by 32-bits (4 bytes).  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#a745a39814ee191f008cfe05513726483">More...</a><br /></td></tr>
<tr class="separator:a745a39814ee191f008cfe05513726483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfd909b5664f5612f48c84573d7a554"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a1bfd909b5664f5612f48c84573d7a554">Read64</a> (const uint8_t *&amp;p)</td></tr>
<tr class="memdesc:a1bfd909b5664f5612f48c84573d7a554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory read of the little endian byte ordered 64-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering, and increment the pointer by 64-bits (8 bytes).  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#a1bfd909b5664f5612f48c84573d7a554">More...</a><br /></td></tr>
<tr class="separator:a1bfd909b5664f5612f48c84573d7a554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b5d0b5321920e95203815e75436213"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#ae1b5d0b5321920e95203815e75436213">Read64</a> (uint8_t *&amp;p)</td></tr>
<tr class="memdesc:ae1b5d0b5321920e95203815e75436213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory read of the little endian byte ordered 64-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering, and increment the pointer by 64-bits (8 bytes).  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#ae1b5d0b5321920e95203815e75436213">More...</a><br /></td></tr>
<tr class="separator:ae1b5d0b5321920e95203815e75436213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e45951383bee975592e2b0a8beb38e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a4e45951383bee975592e2b0a8beb38e6">Write16</a> (uint8_t *&amp;p, uint16_t v)</td></tr>
<tr class="memdesc:a4e45951383bee975592e2b0a8beb38e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory write of the target system byte ordered 16-bit value to the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in little endian byte ordering.  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#a4e45951383bee975592e2b0a8beb38e6">More...</a><br /></td></tr>
<tr class="separator:a4e45951383bee975592e2b0a8beb38e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb60d61fceca23f5e54074d8dd459127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#aeb60d61fceca23f5e54074d8dd459127">Write32</a> (uint8_t *&amp;p, uint32_t v)</td></tr>
<tr class="memdesc:aeb60d61fceca23f5e54074d8dd459127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory write of the target system byte ordered 32-bit value to the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in little endian byte ordering.  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#aeb60d61fceca23f5e54074d8dd459127">More...</a><br /></td></tr>
<tr class="separator:aeb60d61fceca23f5e54074d8dd459127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8b87c1a8e3457da103f5cd2ef86317"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a2f8b87c1a8e3457da103f5cd2ef86317">Write64</a> (uint8_t *&amp;p, uint64_t v)</td></tr>
<tr class="memdesc:a2f8b87c1a8e3457da103f5cd2ef86317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a, potentially unaligned, memory write of the target system byte ordered 64-bit value to the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in little endian byte ordering.  <a href="namespacechip_1_1_encoding_1_1_little_endian.html#a2f8b87c1a8e3457da103f5cd2ef86317">More...</a><br /></td></tr>
<tr class="separator:a2f8b87c1a8e3457da103f5cd2ef86317"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace provides functions for:</p>
<ul>
<li>
Performing byte reordering, relative to the host system, by value of little endian byte ordered values for 16-, 32-, and 64-bit types. </li>
<li>
Safely performing simple, efficient memory-mapped accesses, potentially to unaligned memory locations, with or without byte reordering, to 8-, 16-, 32-, and 64-bit little endian byte ordered quantities, both with and without pointer management. </li>
</ul>
<p>On little endian host systems no actual byte reordering will occur. On other systems, byte reordering is peformed as appropriate. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a0459604c3ee9bf6cfc40add037ab08e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0459604c3ee9bf6cfc40add037ab08e3">&#9670;&nbsp;</a></span>PacketBufferWriter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html#a0459604c3ee9bf6cfc40add037ab08e3">chip::Encoding::LittleEndian::PacketBufferWriter</a> = typedef <a class="el" href="classchip_1_1_encoding_1_1_packet_buffer_writer_base.html">PacketBufferWriterBase</a>&lt;<a class="el" href="classchip_1_1_encoding_1_1_little_endian_1_1_buffer_writer.html">chip::Encoding::LittleEndian::BufferWriter</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ada986f033af897efecd4ccdc1d59bde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada986f033af897efecd4ccdc1d59bde6">&#9670;&nbsp;</a></span>Get16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t chip::Encoding::LittleEndian::Get16 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory read of the little endian byte ordered 16-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer address, potentially unaligned, to read the 16-bit little endian byte ordered value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 16-bit value at the specified pointer address, if necessary, byte reordered. </dd></dl>

</div>
</div>
<a id="abc5c91cdceeef2f64f41155b162087fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5c91cdceeef2f64f41155b162087fb">&#9670;&nbsp;</a></span>Get32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t chip::Encoding::LittleEndian::Get32 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory read of the little endian byte ordered 32-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer address, potentially unaligned, to read the 32-bit little endian byte ordered value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit value at the specified pointer address, if necessary, byte reordered. </dd></dl>

</div>
</div>
<a id="a403fc75ec23bcada414823fb4627bc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403fc75ec23bcada414823fb4627bc9a">&#9670;&nbsp;</a></span>Get64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t chip::Encoding::LittleEndian::Get64 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory read of the little endian byte ordered 64-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer address, potentially unaligned, to read the 64-bit little endian byte ordered value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 64-bit value at the specified pointer address, if necessary, byte reordered. </dd></dl>

</div>
</div>
<a id="a2d72145b506ff674ee188d2ce048126f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d72145b506ff674ee188d2ce048126f">&#9670;&nbsp;</a></span>HostSwap16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t chip::Encoding::LittleEndian::HostSwap16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This conditionally performs, as necessary for the target system, a byte order swap by value of the specified 16-bit value, presumed to be in little endian byte ordering to the target system (i.e. </p>
<p>host) byte ordering.</p>
<p>Consequently, on little endian target systems, this is a no-op and on big endian target systems, this performs a reordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The 16-bit value to be byte order swapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input value, if necessary, byte order swapped. </dd></dl>

</div>
</div>
<a id="a03c5268e4ad53dcb8945af270f0b17b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c5268e4ad53dcb8945af270f0b17b1">&#9670;&nbsp;</a></span>HostSwap32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t chip::Encoding::LittleEndian::HostSwap32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This conditionally performs, as necessary for the target system, a byte order swap by value of the specified 32-bit value, presumed to be in little endian byte ordering to the target system (i.e. </p>
<p>host) byte ordering.</p>
<p>Consequently, on little endian target systems, this is a no-op and on big endian target systems, this performs a reordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The 32-bit value to be byte order swapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input value, if necessary, byte order swapped. </dd></dl>

</div>
</div>
<a id="aefc7ea2318459a8c6385fafea9c63fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc7ea2318459a8c6385fafea9c63fb3">&#9670;&nbsp;</a></span>HostSwap64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t chip::Encoding::LittleEndian::HostSwap64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This conditionally performs, as necessary for the target system, a byte order swap by value of the specified 64-bit value, presumed to be in little endian byte ordering to the target system (i.e. </p>
<p>host) byte ordering.</p>
<p>Consequently, on little endian target systems, this is a no-op and on big endian target systems, this performs a reordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The 64-bit value to be byte order swapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input value, if necessary, byte order swapped. </dd></dl>

</div>
</div>
<a id="a48dfe448d79c9e0f966af13b2fb90baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dfe448d79c9e0f966af13b2fb90baf">&#9670;&nbsp;</a></span>Put16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chip::Encoding::LittleEndian::Put16 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory write of the target system byte ordered 16-bit value to the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in little endian byte ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer address, potentially unaligned, to write the target system byte ordered 16-bit value to in little endian byte ordering.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The 16-bit value to write, if necessary, byte reordered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31231f899bbec463f5fcee19734581fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31231f899bbec463f5fcee19734581fb">&#9670;&nbsp;</a></span>Put32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chip::Encoding::LittleEndian::Put32 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory write of the target system byte ordered 32-bit value to the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in little endian byte ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer address, potentially unaligned, to write the target system byte ordered 32-bit value to in little endian byte ordering.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The 32-bit value to write, if necessary, byte reordered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a630396930c94e3f410f89f3de5f62161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630396930c94e3f410f89f3de5f62161">&#9670;&nbsp;</a></span>Put64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chip::Encoding::LittleEndian::Put64 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory write of the target system byte ordered 64-bit value to the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in little endian byte ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer address, potentially unaligned, to write the target system byte ordered 64-bit value to in little endian byte ordering.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The 64-bit value to write, if necessary, byte reordered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e38e5cb39ab0fa8b8158001c8e20ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e38e5cb39ab0fa8b8158001c8e20ffd">&#9670;&nbsp;</a></span>Read16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t chip::Encoding::LittleEndian::Read16 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory read of the little endian byte ordered 16-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering, and increment the pointer by 16-bits (2 bytes). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>A reference to a constant pointer address, potentially unaligned, to read the 16-bit little endian byte ordered value from and to then increment by 16- bits (2 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 16-bit value at the specified pointer address, if necessary, byte order swapped. </dd></dl>

</div>
</div>
<a id="a20965fe08826d3ab9b20229a146c72c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20965fe08826d3ab9b20229a146c72c3">&#9670;&nbsp;</a></span>Read16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t chip::Encoding::LittleEndian::Read16 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory read of the little endian byte ordered 16-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering, and increment the pointer by 16-bits (2 bytes). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>A reference to a pointer address, potentially unaligned, to read the 16-bit little endian byte ordered value from and to then increment by 16- bits (2 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 16-bit value at the specified pointer address, if necessary, byte order swapped. </dd></dl>

</div>
</div>
<a id="a1a0a2d905650b2672238de0219847290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0a2d905650b2672238de0219847290">&#9670;&nbsp;</a></span>Read32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t chip::Encoding::LittleEndian::Read32 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory read of the little endian byte ordered 32-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering, and increment the pointer by 32-bits (4 bytes). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>A reference to a constant pointer address, potentially unaligned, to read the 32-bit little endian byte ordered value from and to then increment by 32- bits (4 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit value at the specified pointer address, if necessary, byte order swapped. </dd></dl>

</div>
</div>
<a id="a745a39814ee191f008cfe05513726483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745a39814ee191f008cfe05513726483">&#9670;&nbsp;</a></span>Read32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t chip::Encoding::LittleEndian::Read32 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory read of the little endian byte ordered 32-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering, and increment the pointer by 32-bits (4 bytes). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>A reference to a pointer address, potentially unaligned, to read the 32-bit little endian byte ordered value from and to then increment by 32- bits (4 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit value at the specified pointer address, if necessary, byte order swapped. </dd></dl>

</div>
</div>
<a id="a1bfd909b5664f5612f48c84573d7a554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfd909b5664f5612f48c84573d7a554">&#9670;&nbsp;</a></span>Read64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t chip::Encoding::LittleEndian::Read64 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory read of the little endian byte ordered 64-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering, and increment the pointer by 64-bits (8 bytes). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>A reference to a constant pointer address, potentially unaligned, to read the 64-bit little endian byte ordered value from and to then increment by 64- bits (8 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 64-bit value at the specified pointer address, if necessary, byte order swapped. </dd></dl>

</div>
</div>
<a id="ae1b5d0b5321920e95203815e75436213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b5d0b5321920e95203815e75436213">&#9670;&nbsp;</a></span>Read64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t chip::Encoding::LittleEndian::Read64 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory read of the little endian byte ordered 64-bit value from the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in target system byte ordering, and increment the pointer by 64-bits (8 bytes). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>A reference to a pointer address, potentially unaligned, to read the 64-bit little endian byte ordered value from and to then increment by 64- bits (8 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 64-bit value at the specified pointer address, if necessary, byte order swapped. </dd></dl>

</div>
</div>
<a id="a4e45951383bee975592e2b0a8beb38e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e45951383bee975592e2b0a8beb38e6">&#9670;&nbsp;</a></span>Write16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chip::Encoding::LittleEndian::Write16 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory write of the target system byte ordered 16-bit value to the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in little endian byte ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A reference to a pointer address, potentially unaligned, to write the target system byte ordered 16-bit value to in little endian byte ordering and to then increment by 16-bits (2 bytes).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The 16-bit value to write, if necessary, byte order swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb60d61fceca23f5e54074d8dd459127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb60d61fceca23f5e54074d8dd459127">&#9670;&nbsp;</a></span>Write32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chip::Encoding::LittleEndian::Write32 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory write of the target system byte ordered 32-bit value to the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in little endian byte ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A reference to a pointer address, potentially unaligned, to write the target system byte ordered 32-bit value to in little endian byte ordering and to then increment by 32-bits (4 bytes).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The 32-bit value to write, if necessary, byte order swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f8b87c1a8e3457da103f5cd2ef86317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8b87c1a8e3457da103f5cd2ef86317">&#9670;&nbsp;</a></span>Write64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chip::Encoding::LittleEndian::Write64 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a, potentially unaligned, memory write of the target system byte ordered 64-bit value to the specified pointer address, perform byte reordering, as necessary, for the target system to put the value in little endian byte ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A reference to a pointer address, potentially unaligned, to write the target system byte ordered 64-bit value to in little endian byte ordering and to then increment by 64-bits (8 bytes).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The 64-bit value to write, if necessary, byte order swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacechip.html">chip</a></li><li class="navelem"><a class="el" href="namespacechip_1_1_encoding.html">Encoding</a></li><li class="navelem"><a class="el" href="namespacechip_1_1_encoding_1_1_little_endian.html">LittleEndian</a></li>
    <li class="footer">Generated on Thu Apr 15 2021 18:57:06 for Connected Home over IP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
