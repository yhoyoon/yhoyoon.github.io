<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Connected Home over IP: chip::System::PacketBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Connected Home over IP
   &#160;<span id="projectnumber">672cf7684</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classchip_1_1_system_1_1_packet_buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classchip_1_1_system_1_1_packet_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">chip::System::PacketBuffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The packet buffer class is the core structure used for manipulating packets of octet-serialized data, usually in the context of a data communications network, like Bluetooth or the Internet protocol.  
 <a href="classchip_1_1_system_1_1_packet_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_system_packet_buffer_8h_source.html">system/SystemPacketBuffer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for chip::System::PacketBuffer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classchip_1_1_system_1_1_packet_buffer.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a46827678a540122d2a6ea6c90c360d61"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a46827678a540122d2a6ea6c90c360d61">AllocSize</a> () const</td></tr>
<tr class="memdesc:a46827678a540122d2a6ea6c90c360d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the allocation including the reserved and payload data spaces but not including space allocated for the <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> structure.  <a href="classchip_1_1_system_1_1_packet_buffer.html#a46827678a540122d2a6ea6c90c360d61">More...</a><br /></td></tr>
<tr class="separator:a46827678a540122d2a6ea6c90c360d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccfaa7a1054db388a2f1ceba4501e17"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a1ccfaa7a1054db388a2f1ceba4501e17">Start</a> () const</td></tr>
<tr class="memdesc:a1ccfaa7a1054db388a2f1ceba4501e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the start of data in a buffer.  <a href="classchip_1_1_system_1_1_packet_buffer.html#a1ccfaa7a1054db388a2f1ceba4501e17">More...</a><br /></td></tr>
<tr class="separator:a1ccfaa7a1054db388a2f1ceba4501e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7feda7eaf9607d291e30d9b57b09926"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#af7feda7eaf9607d291e30d9b57b09926">SetStart</a> (uint8_t *aNewStart)</td></tr>
<tr class="memdesc:af7feda7eaf9607d291e30d9b57b09926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the the start of data in a buffer, adjusting length and total length accordingly.  <a href="classchip_1_1_system_1_1_packet_buffer.html#af7feda7eaf9607d291e30d9b57b09926">More...</a><br /></td></tr>
<tr class="separator:af7feda7eaf9607d291e30d9b57b09926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac3f03ccf49d369aebc939d0b7b5edb"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a9ac3f03ccf49d369aebc939d0b7b5edb">DataLength</a> () const</td></tr>
<tr class="memdesc:a9ac3f03ccf49d369aebc939d0b7b5edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length, in bytes, of data in a packet buffer.  <a href="classchip_1_1_system_1_1_packet_buffer.html#a9ac3f03ccf49d369aebc939d0b7b5edb">More...</a><br /></td></tr>
<tr class="separator:a9ac3f03ccf49d369aebc939d0b7b5edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dbb9c3b0110f2304d5e521c4d40570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a66dbb9c3b0110f2304d5e521c4d40570">SetDataLength</a> (uint16_t aNewLen, const <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> &amp;aChainHead)</td></tr>
<tr class="memdesc:a66dbb9c3b0110f2304d5e521c4d40570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the length, in bytes, of data in a packet buffer, adjusting total length accordingly.  <a href="classchip_1_1_system_1_1_packet_buffer.html#a66dbb9c3b0110f2304d5e521c4d40570">More...</a><br /></td></tr>
<tr class="separator:a66dbb9c3b0110f2304d5e521c4d40570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e64082c33297ac903d1265faea9f7c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a7e64082c33297ac903d1265faea9f7c2">SetDataLength</a> (uint16_t aNewLen)</td></tr>
<tr class="separator:a7e64082c33297ac903d1265faea9f7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c9e4fe5907e0a1c15ac5132f7c1371"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#ac9c9e4fe5907e0a1c15ac5132f7c1371">TotalLength</a> () const</td></tr>
<tr class="memdesc:ac9c9e4fe5907e0a1c15ac5132f7c1371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total length of packet data in the buffer chain.  <a href="classchip_1_1_system_1_1_packet_buffer.html#ac9c9e4fe5907e0a1c15ac5132f7c1371">More...</a><br /></td></tr>
<tr class="separator:ac9c9e4fe5907e0a1c15ac5132f7c1371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7334f74539888f493225858876763616"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a7334f74539888f493225858876763616">MaxDataLength</a> () const</td></tr>
<tr class="memdesc:a7334f74539888f493225858876763616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum amount, in bytes, of data that will fit in the buffer given the current start position and buffer size.  <a href="classchip_1_1_system_1_1_packet_buffer.html#a7334f74539888f493225858876763616">More...</a><br /></td></tr>
<tr class="separator:a7334f74539888f493225858876763616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fcec49262eac0bdcd3fe4ae12fb14f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a87fcec49262eac0bdcd3fe4ae12fb14f">AvailableDataLength</a> () const</td></tr>
<tr class="memdesc:a87fcec49262eac0bdcd3fe4ae12fb14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes of data that can be added to the current buffer given the current start position and data length.  <a href="classchip_1_1_system_1_1_packet_buffer.html#a87fcec49262eac0bdcd3fe4ae12fb14f">More...</a><br /></td></tr>
<tr class="separator:a87fcec49262eac0bdcd3fe4ae12fb14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe23fb3ab616eb2a0d656371a2d18f1"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#abbe23fb3ab616eb2a0d656371a2d18f1">ReservedSize</a> () const</td></tr>
<tr class="memdesc:abbe23fb3ab616eb2a0d656371a2d18f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes within the current buffer between the start of the buffer and the current data start position.  <a href="classchip_1_1_system_1_1_packet_buffer.html#abbe23fb3ab616eb2a0d656371a2d18f1">More...</a><br /></td></tr>
<tr class="separator:abbe23fb3ab616eb2a0d656371a2d18f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c0891ecc48a6445f0cb0dcff5dee02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#ae4c0891ecc48a6445f0cb0dcff5dee02">HasChainedBuffer</a> () const</td></tr>
<tr class="memdesc:ae4c0891ecc48a6445f0cb0dcff5dee02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether there are any additional buffers chained to the current buffer.  <a href="classchip_1_1_system_1_1_packet_buffer.html#ae4c0891ecc48a6445f0cb0dcff5dee02">More...</a><br /></td></tr>
<tr class="separator:ae4c0891ecc48a6445f0cb0dcff5dee02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11c699a8ec904363af2af0d4cd46014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#ac11c699a8ec904363af2af0d4cd46014">AddToEnd</a> (<a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> &amp;&amp;aPacket)</td></tr>
<tr class="memdesc:ac11c699a8ec904363af2af0d4cd46014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given packet buffer to the end of the buffer chain, adjusting the total length of each buffer in the chain accordingly.  <a href="classchip_1_1_system_1_1_packet_buffer.html#ac11c699a8ec904363af2af0d4cd46014">More...</a><br /></td></tr>
<tr class="separator:ac11c699a8ec904363af2af0d4cd46014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0d719e7c335c310a720b79750fc6f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a8e0d719e7c335c310a720b79750fc6f3">CompactHead</a> ()</td></tr>
<tr class="memdesc:a8e0d719e7c335c310a720b79750fc6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move data from subsequent buffers in the chain into the current buffer until it is full.  <a href="classchip_1_1_system_1_1_packet_buffer.html#a8e0d719e7c335c310a720b79750fc6f3">More...</a><br /></td></tr>
<tr class="separator:a8e0d719e7c335c310a720b79750fc6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848ce6ace3e83f9f34d56df533e5c18c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a848ce6ace3e83f9f34d56df533e5c18c">ConsumeHead</a> (uint16_t aConsumeLength)</td></tr>
<tr class="memdesc:a848ce6ace3e83f9f34d56df533e5c18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the current buffer to indicate the amount of data consumed.  <a href="classchip_1_1_system_1_1_packet_buffer.html#a848ce6ace3e83f9f34d56df533e5c18c">More...</a><br /></td></tr>
<tr class="separator:a848ce6ace3e83f9f34d56df533e5c18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e32db66d6fc0d6386f80aef77b60bd"><td class="memItemLeft" align="right" valign="top">CHECK_RETURN_VALUE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#ac2e32db66d6fc0d6386f80aef77b60bd">EnsureReservedSize</a> (uint16_t aReservedSize)</td></tr>
<tr class="memdesc:ac2e32db66d6fc0d6386f80aef77b60bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure the buffer has at least the specified amount of reserved space.  <a href="classchip_1_1_system_1_1_packet_buffer.html#ac2e32db66d6fc0d6386f80aef77b60bd">More...</a><br /></td></tr>
<tr class="separator:ac2e32db66d6fc0d6386f80aef77b60bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559d872bec7a58369f763fb763b368e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a559d872bec7a58369f763fb763b368e2">AlignPayload</a> (uint16_t aAlignBytes)</td></tr>
<tr class="memdesc:a559d872bec7a58369f763fb763b368e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align the buffer payload on the specified bytes boundary.  <a href="classchip_1_1_system_1_1_packet_buffer.html#a559d872bec7a58369f763fb763b368e2">More...</a><br /></td></tr>
<tr class="separator:a559d872bec7a58369f763fb763b368e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5ef0d9c23c1a9f63d2620f9b4d470d"><td class="memItemLeft" align="right" valign="top">CHECK_RETURN_VALUE <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a6c5ef0d9c23c1a9f63d2620f9b4d470d">Next</a> ()</td></tr>
<tr class="memdesc:a6c5ef0d9c23c1a9f63d2620f9b4d470d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next buffer in a buffer chain.  <a href="classchip_1_1_system_1_1_packet_buffer.html#a6c5ef0d9c23c1a9f63d2620f9b4d470d">More...</a><br /></td></tr>
<tr class="separator:a6c5ef0d9c23c1a9f63d2620f9b4d470d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4ca18105abaf840bbeea134d454926"><td class="memItemLeft" align="right" valign="top">CHECK_RETURN_VALUE <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#aec4ca18105abaf840bbeea134d454926">Last</a> ()</td></tr>
<tr class="memdesc:aec4ca18105abaf840bbeea134d454926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last buffer in a buffer chain.  <a href="classchip_1_1_system_1_1_packet_buffer.html#aec4ca18105abaf840bbeea134d454926">More...</a><br /></td></tr>
<tr class="separator:aec4ca18105abaf840bbeea134d454926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed8f36d27742745d384d17ea535138d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_h_i_p_error_8h.html#ab17a41277f81480d902cc2f8bb6d87d1">CHIP_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a4ed8f36d27742745d384d17ea535138d">Read</a> (uint8_t *buf, size_t length) const</td></tr>
<tr class="memdesc:a4ed8f36d27742745d384d17ea535138d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from the payloads of a chain of packet buffers until a given amount of data has been copied.  <a href="classchip_1_1_system_1_1_packet_buffer.html#a4ed8f36d27742745d384d17ea535138d">More...</a><br /></td></tr>
<tr class="separator:a4ed8f36d27742745d384d17ea535138d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39458842d4f1c17e7d9cbef2310ed9a"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:af39458842d4f1c17e7d9cbef2310ed9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_c_h_i_p_error_8h.html#ab17a41277f81480d902cc2f8bb6d87d1">CHIP_ERROR</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#af39458842d4f1c17e7d9cbef2310ed9a">Read</a> (uint8_t(&amp;buf)[N]) const</td></tr>
<tr class="separator:af39458842d4f1c17e7d9cbef2310ed9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a01bd9ad36fd45a4dd1a0edc707348b9d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a01bd9ad36fd45a4dd1a0edc707348b9d">Check</a> (const <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html">PacketBuffer</a> *<a class="el" href="_c_h_i_p_device_controller-_j_n_i_8cpp.html#a0c1b800f8e945f2a4544cb4008ffb418">buffer</a>)</td></tr>
<tr class="memdesc:a01bd9ad36fd45a4dd1a0edc707348b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an implementation-defined check on the validity of a <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> pointer.  <a href="classchip_1_1_system_1_1_packet_buffer.html#a01bd9ad36fd45a4dd1a0edc707348b9d">More...</a><br /></td></tr>
<tr class="separator:a01bd9ad36fd45a4dd1a0edc707348b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a4c28fb4145851d4181777b1dfa0bd14d"><td class="memItemLeft" align="right" valign="top">static constexpr uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a4c28fb4145851d4181777b1dfa0bd14d">kMaxSizeWithoutReserve</a> = (LWIP_MEM_ALIGN_SIZE(PBUF_POOL_BUFSIZE) - PacketBuffer::kStructureSize)</td></tr>
<tr class="memdesc:a4c28fb4145851d4181777b1dfa0bd14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size buffer an application can allocate with no protocol header reserve.  <a href="classchip_1_1_system_1_1_packet_buffer.html#a4c28fb4145851d4181777b1dfa0bd14d">More...</a><br /></td></tr>
<tr class="separator:a4c28fb4145851d4181777b1dfa0bd14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4875bbfd65cdf2f011b0a1d2c21aece"><td class="memItemLeft" align="right" valign="top">static constexpr uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#ae4875bbfd65cdf2f011b0a1d2c21aece">kDefaultHeaderReserve</a> = <a class="el" href="_system_config_8h.html#a5daf5dd98b8ea4a0c1eca7f865e7a2de">CHIP_SYSTEM_CONFIG_HEADER_RESERVE_SIZE</a></td></tr>
<tr class="memdesc:ae4875bbfd65cdf2f011b0a1d2c21aece"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes to reserve in a network packet buffer to contain all the possible protocol encapsulation headers before the application data.  <a href="classchip_1_1_system_1_1_packet_buffer.html#ae4875bbfd65cdf2f011b0a1d2c21aece">More...</a><br /></td></tr>
<tr class="separator:ae4875bbfd65cdf2f011b0a1d2c21aece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e428dfe0549658479bde920d959e64"><td class="memItemLeft" align="right" valign="top">static constexpr uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#af7e428dfe0549658479bde920d959e64">kMaxSize</a> = <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a4c28fb4145851d4181777b1dfa0bd14d">kMaxSizeWithoutReserve</a> - <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#ae4875bbfd65cdf2f011b0a1d2c21aece">kDefaultHeaderReserve</a></td></tr>
<tr class="memdesc:af7e428dfe0549658479bde920d959e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size buffer an application can allocate with the default protocol header reserve.  <a href="classchip_1_1_system_1_1_packet_buffer.html#af7e428dfe0549658479bde920d959e64">More...</a><br /></td></tr>
<tr class="separator:af7e428dfe0549658479bde920d959e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8a7d1a632c69ee5dc73131aa48d78cd6"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a8a7d1a632c69ee5dc73131aa48d78cd6">PacketBufferHandle</a></td></tr>
<tr class="separator:a8a7d1a632c69ee5dc73131aa48d78cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9be0bb9d8764a36c2857392a29e91e"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#aca9be0bb9d8764a36c2857392a29e91e">::PacketBufferTest</a></td></tr>
<tr class="separator:aca9be0bb9d8764a36c2857392a29e91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The packet buffer class is the core structure used for manipulating packets of octet-serialized data, usually in the context of a data communications network, like Bluetooth or the Internet protocol. </p>
<p>In LwIP-based environments, this class is built on top of the pbuf structure defined in that library. In the absence of LwIP, chip provides either a malloc-based implementation, or a pool-based implementation that closely approximates the memory challenges of deeply embedded devices.</p>
<p>The <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> class, like many similar structures used in layered network stacks, provide a mechanism to reserve space for protocol headers at each layer of a configurable communication stack. For details, see <code><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#ab9d44448b8b4aa3570563026a15926fd" title="Allocates a packet buffer.">PacketBufferHandle::New()</a></code> as well as LwIP documentation.</p>
<p><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> objects are reference-counted, and normally held and used through a <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> that owns one of the counted references. When a <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> goes out of scope, its reference is released. To take ownership, a function takes a <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> by value. To borrow ownership, a function takes a <code>const <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> &amp;</code>.</p>
<p>New objects of <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> class are initialized at the beginning of an allocation of memory obtained from the underlying environment, e.g. from LwIP pbuf target pools, from the standard C library heap, from an internal buffer pool. In the simple pool case, the size of the data buffer is PacketBuffer::kBlockSize.</p>
<p><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> objects may be chained to accomodate larger payloads. Chaining, however, is not transparent, and users of the class must explicitly decide to support chaining. Examples of classes written with chaining support are as follows: </p><pre class="fragment">@ref chip::chipTLVReader
@ref chip::chipTLVWriter
</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac11c699a8ec904363af2af0d4cd46014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11c699a8ec904363af2af0d4cd46014">&#9670;&nbsp;</a></span>AddToEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chip::System::PacketBuffer::AddToEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>aPacket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the given packet buffer to the end of the buffer chain, adjusting the total length of each buffer in the chain accordingly. </p>
<dl class="section note"><dt>Note</dt><dd>The current packet buffer must be the head of the buffer chain for the lengths to be adjusted properly.</dd>
<dd>
Ownership is transferred from the argument to the <code>next</code> link at the end of the current chain.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPacket</td><td>- the packet buffer to be added to the end of the current chain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a559d872bec7a58369f763fb763b368e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559d872bec7a58369f763fb763b368e2">&#9670;&nbsp;</a></span>AlignPayload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chip::System::PacketBuffer::AlignPayload </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aAlignBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align the buffer payload on the specified bytes boundary. </p>
<p>Moving the payload in the buffer forward if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aAlignBytes</td><td>- specifies number of bytes alignment for the payload start pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if alignment is successful, <code>false</code> if there's not enough room in the buffer. </dd></dl>

</div>
</div>
<a id="a46827678a540122d2a6ea6c90c360d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46827678a540122d2a6ea6c90c360d61">&#9670;&nbsp;</a></span>AllocSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t chip::System::PacketBuffer::AllocSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the allocation including the reserved and payload data spaces but not including space allocated for the <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> structure. </p>
<dl class="section note"><dt>Note</dt><dd>The allocation size is equal to or greater than the <code>aAllocSize</code> parameter to the <code>Create</code> method).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>size of the allocation </dd></dl>

</div>
</div>
<a id="a87fcec49262eac0bdcd3fe4ae12fb14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fcec49262eac0bdcd3fe4ae12fb14f">&#9670;&nbsp;</a></span>AvailableDataLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t chip::System::PacketBuffer::AvailableDataLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bytes of data that can be added to the current buffer given the current start position and data length. </p>
<dl class="section return"><dt>Returns</dt><dd>the length, in bytes, of data that will fit in the current buffer given the current start position and data length. </dd></dl>

</div>
</div>
<a id="a01bd9ad36fd45a4dd1a0edc707348b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bd9ad36fd45a4dd1a0edc707348b9d">&#9670;&nbsp;</a></span>Check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void chip::System::PacketBuffer::Check </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html">PacketBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an implementation-defined check on the validity of a <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> pointer. </p>
<p>Unless enabled by <a class="el" href="_c_h_i_p_config_8h.html#a2da017299cd8840077ef21cdbbc3ffaf" title="Enable (1) or disable (0) building with additional code for memory-related checks.">CHIP_CONFIG_MEMORY_DEBUG_CHECKS</a> == 1, this function does nothing.</p>
<p>When enabled, it performs an implementation- and configuration-defined check on the validity of the packet buffer. It MAY log an error and/or abort the program if the packet buffer or the implementation-defined memory management system is in a faulty state. (Some configurations may not actually perform any check.)</p>
<dl class="section note"><dt>Note</dt><dd>A null pointer is not considered faulty.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>- the packet buffer to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e0d719e7c335c310a720b79750fc6f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0d719e7c335c310a720b79750fc6f3">&#9670;&nbsp;</a></span>CompactHead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chip::System::PacketBuffer::CompactHead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move data from subsequent buffers in the chain into the current buffer until it is full. </p>
<p>Only the current buffer is compacted: the data within the current buffer is moved to the front of the buffer, eliminating any reserved space. The remaining available space is filled with data moved from subsequent buffers in the chain, until the current buffer is full. If a subsequent buffer in the chain is moved into the current buffer in its entirety, it is removed from the chain and freed. The method takes no parameters, returns no results and cannot fail. </p>

</div>
</div>
<a id="a848ce6ace3e83f9f34d56df533e5c18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848ce6ace3e83f9f34d56df533e5c18c">&#9670;&nbsp;</a></span>ConsumeHead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chip::System::PacketBuffer::ConsumeHead </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aConsumeLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust the current buffer to indicate the amount of data consumed. </p>
<p>Advance the data start position in the current buffer by the specified amount, in bytes, up to the length of data in the buffer. Decrease the length and total length by the amount consumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aConsumeLength</td><td>- number of bytes to consume from the current buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ac3f03ccf49d369aebc939d0b7b5edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac3f03ccf49d369aebc939d0b7b5edb">&#9670;&nbsp;</a></span>DataLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t chip::System::PacketBuffer::DataLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length, in bytes, of data in a packet buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>length, in bytes (current payload length). </dd></dl>

</div>
</div>
<a id="ac2e32db66d6fc0d6386f80aef77b60bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e32db66d6fc0d6386f80aef77b60bd">&#9670;&nbsp;</a></span>EnsureReservedSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chip::System::PacketBuffer::EnsureReservedSize </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aReservedSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure the buffer has at least the specified amount of reserved space. </p>
<p>Ensure the buffer has at least the specified amount of reserved space, moving the data in the buffer forward to make room if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aReservedSize</td><td>- number of bytes desired for the headers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the requested reserved size is available, <code>false</code> if there's not enough room in the buffer. </dd></dl>

</div>
</div>
<a id="ae4c0891ecc48a6445f0cb0dcff5dee02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c0891ecc48a6445f0cb0dcff5dee02">&#9670;&nbsp;</a></span>HasChainedBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool chip::System::PacketBuffer::HasChainedBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether there are any additional buffers chained to the current buffer. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there is a chained buffer. </dd></dl>

</div>
</div>
<a id="aec4ca18105abaf840bbeea134d454926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4ca18105abaf840bbeea134d454926">&#9670;&nbsp;</a></span>Last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> chip::System::PacketBuffer::Last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the last buffer in a buffer chain. </p>
<dl class="section return"><dt>Returns</dt><dd>a handle to the last buffer in the buffer chain. </dd></dl>

</div>
</div>
<a id="a7334f74539888f493225858876763616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7334f74539888f493225858876763616">&#9670;&nbsp;</a></span>MaxDataLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t chip::System::PacketBuffer::MaxDataLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum amount, in bytes, of data that will fit in the buffer given the current start position and buffer size. </p>
<dl class="section return"><dt>Returns</dt><dd>number of bytes that fits in the buffer given the current start position. </dd></dl>

</div>
</div>
<a id="a6c5ef0d9c23c1a9f63d2620f9b4d470d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5ef0d9c23c1a9f63d2620f9b4d470d">&#9670;&nbsp;</a></span>Next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> chip::System::PacketBuffer::Next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next buffer in a buffer chain. </p>
<p>If there is no next buffer, the handle will have <code>IsNull()</code> <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a handle to the next buffer in the buffer chain. </dd></dl>

</div>
</div>
<a id="a4ed8f36d27742745d384d17ea535138d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed8f36d27742745d384d17ea535138d">&#9670;&nbsp;</a></span>Read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_h_i_p_error_8h.html#ab17a41277f81480d902cc2f8bb6d87d1">CHIP_ERROR</a> chip::System::PacketBuffer::Read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from the payloads of a chain of packet buffers until a given amount of data has been copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Destination buffer; must be at least <em>length</em> bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Destination buffer length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="_c_h_i_p_error_8h.html#ac088b867f93d086a00c59c13d2833f24" title="A buffer is too small.">CHIP_ERROR_BUFFER_TOO_SMALL</a></td><td>If the total length of the payloads in the chain is less than the requested <em>length</em>. </td></tr>
    <tr><td class="paramname"><a class="el" href="_c_h_i_p_error_8h.html#a68c26998d841bb7b34f0d32093957a78" title="Internal error.">CHIP_ERROR_INTERNAL</a></td><td>In case of an inconsistency in the buffer chain. </td></tr>
    <tr><td class="paramname"><a class="el" href="_c_h_i_p_error_8h.html#a255ed42b89227e34eef134084739716e" title="This defines the CHIP error code for success or no error. This value may be configured via CHIP_CONFI...">CHIP_NO_ERROR</a></td><td>If the requested payload has been copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af39458842d4f1c17e7d9cbef2310ed9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39458842d4f1c17e7d9cbef2310ed9a">&#9670;&nbsp;</a></span>Read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_h_i_p_error_8h.html#ab17a41277f81480d902cc2f8bb6d87d1">CHIP_ERROR</a> chip::System::PacketBuffer::Read </td>
          <td>(</td>
          <td class="paramtype">uint8_t(&amp;)&#160;</td>
          <td class="paramname"><em>buf</em>[N]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abbe23fb3ab616eb2a0d656371a2d18f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe23fb3ab616eb2a0d656371a2d18f1">&#9670;&nbsp;</a></span>ReservedSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t chip::System::PacketBuffer::ReservedSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bytes within the current buffer between the start of the buffer and the current data start position. </p>
<dl class="section return"><dt>Returns</dt><dd>the amount, in bytes, of space between the start of the buffer and the current data start position. </dd></dl>

</div>
</div>
<a id="a7e64082c33297ac903d1265faea9f7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e64082c33297ac903d1265faea9f7c2">&#9670;&nbsp;</a></span>SetDataLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chip::System::PacketBuffer::SetDataLength </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aNewLen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66dbb9c3b0110f2304d5e521c4d40570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66dbb9c3b0110f2304d5e521c4d40570">&#9670;&nbsp;</a></span>SetDataLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chip::System::PacketBuffer::SetDataLength </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aNewLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>aChainHead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the length, in bytes, of data in a packet buffer, adjusting total length accordingly. </p>
<p>The function sets the length, in bytes, of the data in the buffer, adjusting the total length appropriately. When the buffer is not the head of the buffer chain (common case: the caller adds data to the last buffer in the <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> chain prior to calling higher layers), the aChainHead <b>must</b> be passed in to properly adjust the total lengths of each buffer ahead of the current buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aNewLen</td><td>- new length, in bytes, of this buffer.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">aChainHead</td><td>- the head of the buffer chain the current buffer belongs to. May be <code>nullptr</code> if the current buffer is the head of the buffer chain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7feda7eaf9607d291e30d9b57b09926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7feda7eaf9607d291e30d9b57b09926">&#9670;&nbsp;</a></span>SetStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void chip::System::PacketBuffer::SetStart </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aNewStart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the the start of data in a buffer, adjusting length and total length accordingly. </p>
<dl class="section note"><dt>Note</dt><dd>The data within the buffer is not moved, only accounting information is changed. The function is commonly used to either strip or prepend protocol headers in a zero-copy way.</dd>
<dd>
This call should not be used on any buffer that is not the head of a buffer chain, as it only alters the current buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aNewStart</td><td>- A pointer to where the new payload should start. newStart will be adjusted internally to fall within the boundaries of the first buffer in the <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> chain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ccfaa7a1054db388a2f1ceba4501e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccfaa7a1054db388a2f1ceba4501e17">&#9670;&nbsp;</a></span>Start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* chip::System::PacketBuffer::Start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the start of data in a buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the start of data. </dd></dl>

</div>
</div>
<a id="ac9c9e4fe5907e0a1c15ac5132f7c1371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c9e4fe5907e0a1c15ac5132f7c1371">&#9670;&nbsp;</a></span>TotalLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t chip::System::PacketBuffer::TotalLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total length of packet data in the buffer chain. </p>
<dl class="section return"><dt>Returns</dt><dd>total length, in octets. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aca9be0bb9d8764a36c2857392a29e91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9be0bb9d8764a36c2857392a29e91e">&#9670;&nbsp;</a></span>::PacketBufferTest</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::PacketBufferTest</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a7d1a632c69ee5dc73131aa48d78cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7d1a632c69ee5dc73131aa48d78cd6">&#9670;&nbsp;</a></span>PacketBufferHandle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae4875bbfd65cdf2f011b0a1d2c21aece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4875bbfd65cdf2f011b0a1d2c21aece">&#9670;&nbsp;</a></span>kDefaultHeaderReserve</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint16_t chip::System::PacketBuffer::kDefaultHeaderReserve = <a class="el" href="_system_config_8h.html#a5daf5dd98b8ea4a0c1eca7f865e7a2de">CHIP_SYSTEM_CONFIG_HEADER_RESERVE_SIZE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bytes to reserve in a network packet buffer to contain all the possible protocol encapsulation headers before the application data. </p>

</div>
</div>
<a id="af7e428dfe0549658479bde920d959e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e428dfe0549658479bde920d959e64">&#9670;&nbsp;</a></span>kMaxSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint16_t chip::System::PacketBuffer::kMaxSize = <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a4c28fb4145851d4181777b1dfa0bd14d">kMaxSizeWithoutReserve</a> - <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#ae4875bbfd65cdf2f011b0a1d2c21aece">kDefaultHeaderReserve</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum size buffer an application can allocate with the default protocol header reserve. </p>

</div>
</div>
<a id="a4c28fb4145851d4181777b1dfa0bd14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c28fb4145851d4181777b1dfa0bd14d">&#9670;&nbsp;</a></span>kMaxSizeWithoutReserve</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint16_t chip::System::PacketBuffer::kMaxSizeWithoutReserve = (LWIP_MEM_ALIGN_SIZE(PBUF_POOL_BUFSIZE) - PacketBuffer::kStructureSize)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum size buffer an application can allocate with no protocol header reserve. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>system/<a class="el" href="_system_packet_buffer_8h_source.html">SystemPacketBuffer.h</a></li>
<li>system/<a class="el" href="_system_packet_buffer_8cpp.html">SystemPacketBuffer.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacechip.html">chip</a></li><li class="navelem"><a class="el" href="namespacechip_1_1_system.html">System</a></li><li class="navelem"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html">PacketBuffer</a></li>
    <li class="footer">Generated on Thu Apr 15 2021 18:57:06 for Connected Home over IP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
