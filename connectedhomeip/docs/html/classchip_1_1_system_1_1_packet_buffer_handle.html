<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Connected Home over IP: chip::System::PacketBufferHandle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Connected Home over IP
   &#160;<span id="projectnumber">672cf7684</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classchip_1_1_system_1_1_packet_buffer_handle.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classchip_1_1_system_1_1_packet_buffer_handle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">chip::System::PacketBufferHandle Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Tracks ownership of a <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a>.  
 <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_system_packet_buffer_8h_source.html">system/SystemPacketBuffer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for chip::System::PacketBufferHandle:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classchip_1_1_system_1_1_packet_buffer_handle.png" usemap="#chip::System::PacketBufferHandle_map" alt=""/>
  <map id="chip::System::PacketBufferHandle_map" name="chip::System::PacketBufferHandle_map">
<area href="classchip_1_1_encrypted_packet_buffer_handle.html" title="Tracks ownership of a encrypted packet buffer." alt="chip::EncryptedPacketBufferHandle" shape="rect" coords="0,56,216,80"/>
<area href="classchip_1_1_system_1_1_lw_i_p_packet_buffer_view.html" title="Provide low-level access to a raw pbuf *, limited to specific classes that interface with LwIP." alt="chip::System::LwIPPacketBufferView" shape="rect" coords="226,56,442,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a14279153678fbc4c48e95ba4b8e96856"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a14279153678fbc4c48e95ba4b8e96856">PacketBufferHandle</a> ()</td></tr>
<tr class="memdesc:a14279153678fbc4c48e95ba4b8e96856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a>.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#a14279153678fbc4c48e95ba4b8e96856">More...</a><br /></td></tr>
<tr class="separator:a14279153678fbc4c48e95ba4b8e96856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77035b73e4b5d0019c836798e7b3318a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a77035b73e4b5d0019c836798e7b3318a">PacketBufferHandle</a> (decltype(nullptr))</td></tr>
<tr class="separator:a77035b73e4b5d0019c836798e7b3318a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823cf98b167e36e6ffdf19f42442718e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a823cf98b167e36e6ffdf19f42442718e">PacketBufferHandle</a> (<a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> &amp;&amp;aOther)</td></tr>
<tr class="memdesc:a823cf98b167e36e6ffdf19f42442718e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> that takes ownership of a <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> from another.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#a823cf98b167e36e6ffdf19f42442718e">More...</a><br /></td></tr>
<tr class="separator:a823cf98b167e36e6ffdf19f42442718e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262408066567f1428d373d4326c1da78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a262408066567f1428d373d4326c1da78">~PacketBufferHandle</a> ()</td></tr>
<tr class="separator:a262408066567f1428d373d4326c1da78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b14d1e8d0711292e9b44378c0528ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a2b14d1e8d0711292e9b44378c0528ee7">operator=</a> (<a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> &amp;&amp;aOther)</td></tr>
<tr class="memdesc:a2b14d1e8d0711292e9b44378c0528ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of a <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> from another <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a>, freeing any existing owned buffer.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#a2b14d1e8d0711292e9b44378c0528ee7">More...</a><br /></td></tr>
<tr class="separator:a2b14d1e8d0711292e9b44378c0528ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca6b3c359c61b42afee177ed4414398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#abca6b3c359c61b42afee177ed4414398">operator=</a> (decltype(nullptr))</td></tr>
<tr class="memdesc:abca6b3c359c61b42afee177ed4414398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free any buffer owned by this handle.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#abca6b3c359c61b42afee177ed4414398">More...</a><br /></td></tr>
<tr class="separator:abca6b3c359c61b42afee177ed4414398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af660c0bd3d2154b16f0eb73da5daa235"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#af660c0bd3d2154b16f0eb73da5daa235">Retain</a> () const</td></tr>
<tr class="memdesc:af660c0bd3d2154b16f0eb73da5daa235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a new handle to an existing buffer.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#af660c0bd3d2154b16f0eb73da5daa235">More...</a><br /></td></tr>
<tr class="separator:af660c0bd3d2154b16f0eb73da5daa235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d24f9586a4f96c9e63d8191c20ee68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html">PacketBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#af4d24f9586a4f96c9e63d8191c20ee68">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:af4d24f9586a4f96c9e63d8191c20ee68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a PackerBuffer's public methods.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#af4d24f9586a4f96c9e63d8191c20ee68">More...</a><br /></td></tr>
<tr class="separator:af4d24f9586a4f96c9e63d8191c20ee68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e13c201b8c13dc611111e3ec3612da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a63e13c201b8c13dc611111e3ec3612da">IsNull</a> () const</td></tr>
<tr class="memdesc:a63e13c201b8c13dc611111e3ec3612da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> is empty, or conversely owns a <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a>.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#a63e13c201b8c13dc611111e3ec3612da">More...</a><br /></td></tr>
<tr class="separator:a63e13c201b8c13dc611111e3ec3612da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0917ef83743d123d742c485871c3d8c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a0917ef83743d123d742c485871c3d8c1">HasSoleOwnership</a> () const</td></tr>
<tr class="memdesc:a0917ef83743d123d742c485871c3d8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> owned by this <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> has unique ownership.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#a0917ef83743d123d742c485871c3d8c1">More...</a><br /></td></tr>
<tr class="separator:a0917ef83743d123d742c485871c3d8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cd3c9ecdc6914acf7da9dad5dd97cf"><td class="memItemLeft" align="right" valign="top">CHECK_RETURN_VALUE <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a76cd3c9ecdc6914acf7da9dad5dd97cf">PopHead</a> ()</td></tr>
<tr class="memdesc:a76cd3c9ecdc6914acf7da9dad5dd97cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach and return the head of a buffer chain while updating this handle to point to the remaining buffers.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#a76cd3c9ecdc6914acf7da9dad5dd97cf">More...</a><br /></td></tr>
<tr class="separator:a76cd3c9ecdc6914acf7da9dad5dd97cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5625ab3a29e3140c3d4baf481949c1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#ab5625ab3a29e3140c3d4baf481949c1a">FreeHead</a> ()</td></tr>
<tr class="memdesc:ab5625ab3a29e3140c3d4baf481949c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the first buffer in a chain.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#ab5625ab3a29e3140c3d4baf481949c1a">More...</a><br /></td></tr>
<tr class="separator:ab5625ab3a29e3140c3d4baf481949c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf17c5539918032fec70f77faebdefe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#aecf17c5539918032fec70f77faebdefe">AddToEnd</a> (<a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> &amp;&amp;aPacket)</td></tr>
<tr class="memdesc:aecf17c5539918032fec70f77faebdefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given packet buffer to the end of the buffer chain, adjusting the total length of each buffer in the chain accordingly.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#aecf17c5539918032fec70f77faebdefe">More...</a><br /></td></tr>
<tr class="separator:aecf17c5539918032fec70f77faebdefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa680c7b45ac6478cddaf24f228b4e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#afa680c7b45ac6478cddaf24f228b4e9d">Consume</a> (uint16_t aConsumeLength)</td></tr>
<tr class="memdesc:afa680c7b45ac6478cddaf24f228b4e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume data in a chain of buffers.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#afa680c7b45ac6478cddaf24f228b4e9d">More...</a><br /></td></tr>
<tr class="separator:afa680c7b45ac6478cddaf24f228b4e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca41ab74b3bd3ae450721848f8289dc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#aca41ab74b3bd3ae450721848f8289dc6">RightSize</a> ()</td></tr>
<tr class="memdesc:aca41ab74b3bd3ae450721848f8289dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the given buffer to a right-sized buffer if applicable.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#aca41ab74b3bd3ae450721848f8289dc6">More...</a><br /></td></tr>
<tr class="separator:aca41ab74b3bd3ae450721848f8289dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6cc43082a435111fbeef7405387074"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a0f6cc43082a435111fbeef7405387074">Advance</a> ()</td></tr>
<tr class="memdesc:a0f6cc43082a435111fbeef7405387074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance this <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> to the next buffer in a chain.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#a0f6cc43082a435111fbeef7405387074">More...</a><br /></td></tr>
<tr class="separator:a0f6cc43082a435111fbeef7405387074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa019194ba9d03e8c897e045b2d341d0a"><td class="memItemLeft" align="right" valign="top">CHECK_RETURN_VALUE <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html">PacketBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#aa019194ba9d03e8c897e045b2d341d0a">UnsafeRelease</a> () &amp;&amp;</td></tr>
<tr class="memdesc:aa019194ba9d03e8c897e045b2d341d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a raw <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> pointer.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#aa019194ba9d03e8c897e045b2d341d0a">More...</a><br /></td></tr>
<tr class="separator:aa019194ba9d03e8c897e045b2d341d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5bd9c4127df0de63128717d304e9f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#afc5bd9c4127df0de63128717d304e9f1">CloneData</a> () const</td></tr>
<tr class="memdesc:afc5bd9c4127df0de63128717d304e9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of a packet buffer (or chain).  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#afc5bd9c4127df0de63128717d304e9f1">More...</a><br /></td></tr>
<tr class="separator:afc5bd9c4127df0de63128717d304e9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12396d2a22f79e43ffc279991cdddb99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a12396d2a22f79e43ffc279991cdddb99">Check</a> () const</td></tr>
<tr class="memdesc:a12396d2a22f79e43ffc279991cdddb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an implementation-defined check on the validity of a <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a>.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#a12396d2a22f79e43ffc279991cdddb99">More...</a><br /></td></tr>
<tr class="separator:a12396d2a22f79e43ffc279991cdddb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a54230fea811c117eeca3bc2b3ed9e5c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a54230fea811c117eeca3bc2b3ed9e5c3">Adopt</a> (<a class="el" href="classchip_1_1_system_1_1_packet_buffer.html">PacketBuffer</a> *<a class="el" href="_c_h_i_p_device_controller-_j_n_i_8cpp.html#a0c1b800f8e945f2a4544cb4008ffb418">buffer</a>)</td></tr>
<tr class="memdesc:a54230fea811c117eeca3bc2b3ed9e5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a new handle to a raw <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> pointer.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#a54230fea811c117eeca3bc2b3ed9e5c3">More...</a><br /></td></tr>
<tr class="separator:a54230fea811c117eeca3bc2b3ed9e5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942e7671ba06d253f146c6ac2faadb18"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a942e7671ba06d253f146c6ac2faadb18">Adopt</a> (pbuf *<a class="el" href="_c_h_i_p_device_controller-_j_n_i_8cpp.html#a0c1b800f8e945f2a4544cb4008ffb418">buffer</a>)</td></tr>
<tr class="separator:a942e7671ba06d253f146c6ac2faadb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d44448b8b4aa3570563026a15926fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#ab9d44448b8b4aa3570563026a15926fd">New</a> (size_t aAvailableSize, uint16_t aReservedSize=<a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#ae4875bbfd65cdf2f011b0a1d2c21aece">PacketBuffer::kDefaultHeaderReserve</a>)</td></tr>
<tr class="memdesc:ab9d44448b8b4aa3570563026a15926fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a packet buffer.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#ab9d44448b8b4aa3570563026a15926fd">More...</a><br /></td></tr>
<tr class="separator:ab9d44448b8b4aa3570563026a15926fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a486c4305df89f772f37f5c29a86967"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a4a486c4305df89f772f37f5c29a86967">NewWithData</a> (const void *aData, size_t aDataSize, uint16_t aAdditionalSize=0, uint16_t aReservedSize=<a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#ae4875bbfd65cdf2f011b0a1d2c21aece">PacketBuffer::kDefaultHeaderReserve</a>)</td></tr>
<tr class="memdesc:a4a486c4305df89f772f37f5c29a86967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a packet buffer with initial contents.  <a href="classchip_1_1_system_1_1_packet_buffer_handle.html#a4a486c4305df89f772f37f5c29a86967">More...</a><br /></td></tr>
<tr class="separator:a4a486c4305df89f772f37f5c29a86967"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a969b989269644ed8222cf725c8cde641"><td class="memItemLeft" align="right" valign="top">static struct pbuf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a969b989269644ed8222cf725c8cde641">GetLwIPpbuf</a> (const <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> &amp;<a class="el" href="_c_h_i_p_device_controller-_j_n_i_8cpp.html#a32a32b86dffbaaf5cb24fd1760ac1a91">handle</a>)</td></tr>
<tr class="separator:a969b989269644ed8222cf725c8cde641"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a15138a5d491c925ad82fb7eef619097b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a15138a5d491c925ad82fb7eef619097b">PacketBuffer</a></td></tr>
<tr class="separator:a15138a5d491c925ad82fb7eef619097b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9be0bb9d8764a36c2857392a29e91e"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#aca9be0bb9d8764a36c2857392a29e91e">::PacketBufferTest</a></td></tr>
<tr class="separator:aca9be0bb9d8764a36c2857392a29e91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Tracks ownership of a <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a>. </p>
<p><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> objects are reference-counted, and normally held and used through a <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> that owns one of the counted references. When a <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> goes out of scope, its reference is released. To take ownership, a function takes a <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> by value. To borrow ownership, a function takes a <code>const <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> &amp;</code>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a14279153678fbc4c48e95ba4b8e96856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14279153678fbc4c48e95ba4b8e96856">&#9670;&nbsp;</a></span>PacketBufferHandle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chip::System::PacketBufferHandle::PacketBufferHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a>. </p>

</div>
</div>
<a id="a77035b73e4b5d0019c836798e7b3318a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77035b73e4b5d0019c836798e7b3318a">&#9670;&nbsp;</a></span>PacketBufferHandle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chip::System::PacketBufferHandle::PacketBufferHandle </td>
          <td>(</td>
          <td class="paramtype">decltype(nullptr)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a823cf98b167e36e6ffdf19f42442718e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823cf98b167e36e6ffdf19f42442718e">&#9670;&nbsp;</a></span>PacketBufferHandle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chip::System::PacketBufferHandle::PacketBufferHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>aOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> that takes ownership of a <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> from another. </p>

</div>
</div>
<a id="a262408066567f1428d373d4326c1da78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262408066567f1428d373d4326c1da78">&#9670;&nbsp;</a></span>~PacketBufferHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chip::System::PacketBufferHandle::~PacketBufferHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aecf17c5539918032fec70f77faebdefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf17c5539918032fec70f77faebdefe">&#9670;&nbsp;</a></span>AddToEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chip::System::PacketBufferHandle::AddToEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>aPacket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given packet buffer to the end of the buffer chain, adjusting the total length of each buffer in the chain accordingly. </p>
<dl class="section note"><dt>Note</dt><dd>The current packet buffer handle must either be the head of the buffer chain for the lengths to be adjusted properly, or be null (in which case it becomes the head).</dd>
<dd>
Ownership is transferred from the argument to the <code>next</code> link at the end of the current chain, or to the handle if it's currently null.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPacket</td><td>- the packet buffer to be added to the end of the current chain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54230fea811c117eeca3bc2b3ed9e5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54230fea811c117eeca3bc2b3ed9e5c3">&#9670;&nbsp;</a></span>Adopt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> chip::System::PacketBufferHandle::Adopt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html">PacketBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a new handle to a raw <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> pointer. </p>
<p>The caller's ownership is transferred to this.</p>
<dl class="section note"><dt>Note</dt><dd>This should only be used in low-level code, e.g. to import buffers from LwIP or a similar stack. </dd></dl>

</div>
</div>
<a id="a942e7671ba06d253f146c6ac2faadb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942e7671ba06d253f146c6ac2faadb18">&#9670;&nbsp;</a></span>Adopt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> chip::System::PacketBufferHandle::Adopt </td>
          <td>(</td>
          <td class="paramtype">pbuf *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f6cc43082a435111fbeef7405387074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6cc43082a435111fbeef7405387074">&#9670;&nbsp;</a></span>Advance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chip::System::PacketBufferHandle::Advance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance this <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> to the next buffer in a chain. </p>
<dl class="section note"><dt>Note</dt><dd>This differs from <code><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#ab5625ab3a29e3140c3d4baf481949c1a" title="Free the first buffer in a chain.">FreeHead()</a></code> in that it does not touch any content in the currently referenced packet buffer; it only changes which buffer this handle owns. (Note that this could result in the previous buffer being freed, if there is no other owner.) <code><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#a0f6cc43082a435111fbeef7405387074" title="Advance this PacketBufferHandle to the next buffer in a chain.">Advance()</a></code> is designed to be used with an additional handle to traverse a buffer chain, whereas <code><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#ab5625ab3a29e3140c3d4baf481949c1a" title="Free the first buffer in a chain.">FreeHead()</a></code> modifies a chain. </dd></dl>

</div>
</div>
<a id="a12396d2a22f79e43ffc279991cdddb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12396d2a22f79e43ffc279991cdddb99">&#9670;&nbsp;</a></span>Check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chip::System::PacketBufferHandle::Check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an implementation-defined check on the validity of a <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a>. </p>
<p>Unless enabled by <a class="el" href="_c_h_i_p_config_8h.html#a2da017299cd8840077ef21cdbbc3ffaf" title="Enable (1) or disable (0) building with additional code for memory-related checks.">CHIP_CONFIG_MEMORY_DEBUG_CHECKS</a> == 1, this function does nothing.</p>
<p>When enabled, it performs an implementation- and configuration-defined check on the validity of the packet buffer. It MAY log an error and/or abort the program if the packet buffer or the implementation-defined memory management system is in a faulty state. (Some configurations may not actually perform any check.)</p>
<dl class="section note"><dt>Note</dt><dd>A null handle is not considered faulty.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPacket</td><td>- the packet buffer handle to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc5bd9c4127df0de63128717d304e9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5bd9c4127df0de63128717d304e9f1">&#9670;&nbsp;</a></span>CloneData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> chip::System::PacketBufferHandle::CloneData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a copy of a packet buffer (or chain). </p>
<dl class="section return"><dt>Returns</dt><dd>empty handle on allocation failure. Otherwise, the returned buffer has the same sizes and contents as the original. </dd></dl>

</div>
</div>
<a id="afa680c7b45ac6478cddaf24f228b4e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa680c7b45ac6478cddaf24f228b4e9d">&#9670;&nbsp;</a></span>Consume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chip::System::PacketBufferHandle::Consume </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aConsumeLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consume data in a chain of buffers. </p>
<p>Consume data in a chain of buffers starting with the current buffer and proceeding through the remaining buffers in the chain. Each buffer that is completely consumed is freed and the handle holds the first buffer (if any) containing the remaining data. The current buffer must be the head of the buffer chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aConsumeLength</td><td>- number of bytes to consume from the current chain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5625ab3a29e3140c3d4baf481949c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5625ab3a29e3140c3d4baf481949c1a">&#9670;&nbsp;</a></span>FreeHead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chip::System::PacketBufferHandle::FreeHead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the first buffer in a chain. </p>
<dl class="section note"><dt>Note</dt><dd>When the buffer chain is referenced by multiple handles, <code><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html#ab5625ab3a29e3140c3d4baf481949c1a" title="Free the first buffer in a chain.">FreeHead()</a></code> will detach the head, but will not forcibly deallocate the head buffer. </dd></dl>

</div>
</div>
<a id="a969b989269644ed8222cf725c8cde641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969b989269644ed8222cf725c8cde641">&#9670;&nbsp;</a></span>GetLwIPpbuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct pbuf* chip::System::PacketBufferHandle::GetLwIPpbuf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0917ef83743d123d742c485871c3d8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0917ef83743d123d742c485871c3d8c1">&#9670;&nbsp;</a></span>HasSoleOwnership()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool chip::System::PacketBufferHandle::HasSoleOwnership </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether the <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> owned by this <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> has unique ownership. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> owned by this <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> is solely owned; return <code>false</code> if it has more than one ownership. </dd></dl>

</div>
</div>
<a id="a63e13c201b8c13dc611111e3ec3612da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e13c201b8c13dc611111e3ec3612da">&#9670;&nbsp;</a></span>IsNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool chip::System::PacketBufferHandle::IsNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether this <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> is empty, or conversely owns a <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> is empty; return <code>false</code> if it owns a <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a>. </dd></dl>

</div>
</div>
<a id="ab9d44448b8b4aa3570563026a15926fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d44448b8b4aa3570563026a15926fd">&#9670;&nbsp;</a></span>New()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> chip::System::PacketBufferHandle::New </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>aAvailableSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aReservedSize</em> = <code><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#ae4875bbfd65cdf2f011b0a1d2c21aece">PacketBuffer::kDefaultHeaderReserve</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a packet buffer. </p>
<p>A packet buffer is conceptually divided into two parts: </p><ul>
<li>Space reserved for network protocol headers. The size of this space normally defaults to a value determined by the network layer configuration, but can be given explicity by <code>aReservedSize</code> for special cases. </li>
<li>Space for application data. The minimum size of this space is given by <code>aAvailableSize</code>, and then <code>Start()</code> provides a pointer to the start of this space.</li>
</ul>
<p>Fails and returns <code>nullptr</code> if no memory is available, or if the size requested is too large. When the sum of <em>aAvailableSize</em> and <em>aReservedSize</em> is no greater than <code><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#a4c28fb4145851d4181777b1dfa0bd14d" title="The maximum size buffer an application can allocate with no protocol header reserve.">PacketBuffer::kMaxSizeWithoutReserve</a></code>, that is guaranteed not to be too large.</p>
<p>On success, it is guaranteed that <code>AvailableDataSize()</code> is no less than <em>aAvailableSize</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aAvailableSize</td><td>Minimum number of octets to for application data (at <code>Start()</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aReservedSize</td><td>Number of octets to reserve for protocol headers (before <code>Start()</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> to the allocated buffer. On fail, <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="a4a486c4305df89f772f37f5c29a86967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a486c4305df89f772f37f5c29a86967">&#9670;&nbsp;</a></span>NewWithData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> chip::System::PacketBufferHandle::NewWithData </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>aData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>aDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aAdditionalSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aReservedSize</em> = <code><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html#ae4875bbfd65cdf2f011b0a1d2c21aece">PacketBuffer::kDefaultHeaderReserve</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a packet buffer with initial contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aData</td><td>Initial buffer contents. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aDataSize</td><td>Size of initial buffer contents. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aAdditionalSize</td><td>Size of additional application data space after the initial contents. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aReservedSize</td><td>Number of octets to reserve for protocol headers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> to the allocated buffer. On fail, <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="af4d24f9586a4f96c9e63d8191c20ee68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d24f9586a4f96c9e63d8191c20ee68">&#9670;&nbsp;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html">PacketBuffer</a>* chip::System::PacketBufferHandle::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a PackerBuffer's public methods. </p>

</div>
</div>
<a id="abca6b3c359c61b42afee177ed4414398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca6b3c359c61b42afee177ed4414398">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a>&amp; chip::System::PacketBufferHandle::operator= </td>
          <td>(</td>
          <td class="paramtype">decltype(nullptr)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free any buffer owned by this handle. </p>

</div>
</div>
<a id="a2b14d1e8d0711292e9b44378c0528ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b14d1e8d0711292e9b44378c0528ee7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a>&amp; chip::System::PacketBufferHandle::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>aOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take ownership of a <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> from another <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a>, freeing any existing owned buffer. </p>

</div>
</div>
<a id="a76cd3c9ecdc6914acf7da9dad5dd97cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cd3c9ecdc6914acf7da9dad5dd97cf">&#9670;&nbsp;</a></span>PopHead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> chip::System::PacketBufferHandle::PopHead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach and return the head of a buffer chain while updating this handle to point to the remaining buffers. </p>
<p>The current buffer must be the head of the chain.</p>
<p>This <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> now holds the ownership formerly held by the head of the chain. The returned <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> holds the ownership formerly held by this.</p>
<dl class="section return"><dt>Returns</dt><dd>the detached buffer formerly at the head of the buffer chain. </dd></dl>

</div>
</div>
<a id="af660c0bd3d2154b16f0eb73da5daa235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af660c0bd3d2154b16f0eb73da5daa235">&#9670;&nbsp;</a></span>Retain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a> chip::System::PacketBufferHandle::Retain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a new handle to an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a> that shares ownership with this. </dd></dl>

</div>
</div>
<a id="aca41ab74b3bd3ae450721848f8289dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca41ab74b3bd3ae450721848f8289dc6">&#9670;&nbsp;</a></span>RightSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chip::System::PacketBufferHandle::RightSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the given buffer to a right-sized buffer if applicable. </p>
<p>Only operates on single buffers (for chains, use <code>CompactHead()</code> and RightSize the tail). Requires that this handle be the only reference to the underlying buffer. </p>

</div>
</div>
<a id="aa019194ba9d03e8c897e045b2d341d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa019194ba9d03e8c897e045b2d341d0a">&#9670;&nbsp;</a></span>UnsafeRelease()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CHECK_RETURN_VALUE <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html">PacketBuffer</a>* chip::System::PacketBufferHandle::UnsafeRelease </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export a raw <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a> pointer. </p>
<p>The <a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html" title="Tracks ownership of a PacketBuffer.">PacketBufferHandle</a>'s ownership is transferred to the caller.</p>
<dl class="section note"><dt>Note</dt><dd>This should only be used in low-level code. The caller owns one counted reference to the <code><a class="el" href="classchip_1_1_system_1_1_packet_buffer.html" title="The packet buffer class is the core structure used for manipulating packets of octet-serialized data,...">PacketBuffer</a></code> and is reponsible for managing it safely.</dd>
<dd>
The ref-qualifier <code>&amp;&amp;</code> requires the caller to use <code>std::move</code> to emphasize that ownership is moved out of this handle. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aca9be0bb9d8764a36c2857392a29e91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9be0bb9d8764a36c2857392a29e91e">&#9670;&nbsp;</a></span>::PacketBufferTest</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::PacketBufferTest</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15138a5d491c925ad82fb7eef619097b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15138a5d491c925ad82fb7eef619097b">&#9670;&nbsp;</a></span>PacketBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classchip_1_1_system_1_1_packet_buffer.html">PacketBuffer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>system/<a class="el" href="_system_packet_buffer_8h_source.html">SystemPacketBuffer.h</a></li>
<li>system/<a class="el" href="_system_packet_buffer_8cpp.html">SystemPacketBuffer.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacechip.html">chip</a></li><li class="navelem"><a class="el" href="namespacechip_1_1_system.html">System</a></li><li class="navelem"><a class="el" href="classchip_1_1_system_1_1_packet_buffer_handle.html">PacketBufferHandle</a></li>
    <li class="footer">Generated on Thu Apr 15 2021 18:57:06 for Connected Home over IP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
